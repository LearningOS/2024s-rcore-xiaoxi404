# 功能总结

原有`sys_get_time`和`sys_task_info`实现逻辑上没有问题，只需要增加修改用户空间数据的功能。用户空间数据修改实现思路是将2个地址空间的结构体都视为`[u8]`数组，然后将内核地址空间中的[u8]数组复制到用户空间的位置。

mmap实现思路是根据`start`地址和`len`构造一个`map_area`，最后调用`push()`函数将该`map_area`push到当前task的`memory_set`。

munmap实现思路是根据`start`地址和`len`构造一个`map_area`，然后在当前task的`memory_set`查找该`map_area`的位置，如果没有找到，报错退出，如果找到，`unmap`和`remove`该`map_area`。

# 问答作业

## 1

PTE的最低8位[7:0]为标志位，RSW的[8:9]2位留给操作系统使用，[53:10]这44位是物理叶号。

- 第0位V决定了该页表项的其余部分是否有效（V=1时有效）。若V=0，则任何遍历到此页表项的虚址转换操作都会导致页错误。
- R、W和X位分别表示此页是否可以读取、写入和执行。如果这三个位都是0，那么这个页表项是指向下一级页表的指针，否则它是页表树的一个叶节点。
- U位表示该页是否是用户页面。若U=0，则U模式不能访问此页面，但S模式可以。若U=1，则U模式下能访问这个页面，而S模式不能。
- G位表示这个映射是否对所有虚址空间有效，硬件可以用这个信息来提高地址转换的性能。这一位通常只用于属于操作系统的页面。
- A位表示自从上次A位被清除以来，该页面是否被访问过。
- D位表示自从上次清除D位以来页面是否被弄脏（例如被写入）。

## 2

### 2.1

缺页造成的异常有：StoreFault，StorePageFault，LoadFault，LoadPageFault

寄存器sstatus的表示异常原因，缺页时其值为StoreFault，StorePageFault，LoadFault或LoadPageFault对应的值

### 2.2

好处：节约内存，提高内存利用效率

### 2.3

SV39占用内存大小为：10GiB/512=20MiB

触发缺页时检查缺页地址是否合法，合法的话开始load并map .txt段，最后让程序回到触发异常的位置继续执行（异常指令再执行一遍）。

### 2.4

swap策略的PTE的存在位为0，PTE的保存PTE的存储设备扇区信息。

## 3

### 3.1

任务切换的时候更换页表，即switch.S的restore下一个任务的寄存器前更换页表

### 3.2

通过设置PTE的U位为0来限制用户态访问内核页面

### 3.3

单页表比双页表更容易实现，在应用高频进行系统调用的时候，采用单页表能够避免频繁地址空间切换的开销，这通常源于快表或cache的失效问题。

### 3.4

双页表实现下，Trap时更换页表。

单页表实现下，任务切换的时候更换页表